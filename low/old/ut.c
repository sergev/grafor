/*
 *      Файл ut.c - машинно-зависимая часть ГРАФОРа,
 *      не связанная с графикой.
 *
 *      Функции:
 *
 *      subroutine ibcd (i, s)
 *      integer i
 *      character s (8)
 *
 *              - преобразование целого числа в текстовое представление.
 *              Целое число i преобразуется в строку s длиной 8 символов
 *              с выравниванием вправо.
 *
 *      subroutine bcd (f, s, n)
 *      real f
 *      character s (8)
 *      integer n
 *
 *              - преобразование вещественного числа в текстовое
 *              представление с указанным количеством знаков после
 *              запятой. Вещественное число f преобразуется в строку s
 *              длиной 8 символов с выравниванием вправо и количеством
 *              знаков после запятой n.
 *
 *      integer function ldbyte (s, n)
 *      character s (n)
 *      integer n
 *
 *              - считывание байта с номером n из строки s в виде целого
 *              числа. Байты нумеруются, начиная с 1.
 *
 *      integer function iadr (i)
 *      <any> i
 *
 *              - вычисление адреса переменной. Адрес возвращается в
 *              виде целого числа.
 *
 *      integer function ipeek (iptr, ioff)
 *      integer iptr
 *      integer ioff
 *
 *              - считывание элемента с номером ioff из массива целых
 *              чисел iptr. Переменная iptr содержит адрес начала
 *              массива, полученный с помощью функции iadr. Элементы
 *              нумеруются, начиная с 1.
 *
 *      real function peek (iptr, ioff)
 *      integer iptr
 *      integer ioff
 *
 *              - считывание элемента с номером ioff из массива
 *              вещественных чисел iptr. Переменная iptr содержит адрес
 *              начала массива, полученный с помощью функции iadr.
 *              Элементы нумеруются, начиная с 1.
 *
 *      subroutinе ipoke (iptr, ioff, i)
 *      integer iptr
 *      integer ioff
 *      integer i
 *
 *              - запись целого числа i в массив вещественных чисел
 *              iptr с номером ioff. Переменная iptr содержит адрес
 *              начала массива, полученный с помощью функции iadr.
 *              Элементы нумеруются, начиная с 1.
 *
 *      subroutine poke (iptr, ioff, f)
 *      integer iptr
 *      integer ioff
 *      real f
 *
 *              - запись вещественного числа f в массив вещественных
 *              чисел iptr с номером ioff. Переменная iptr содержит
 *              адрес начала массива, полученный с помощью функции
 *              iadr. Элементы нумеруются, начиная с 1.
 */

/*
 *      В настоящий момент поддерживаются два соглашения
 *      о связях между Си и фортраном:
 *
 *      1.      Для вызова фортран-функции из Си к имени нужно добавить
 *              подчерк. Порядок параметров - тот же. Параметры
 *              передаются по ссылке. Типы integer и real в фортране
 *              соответствует long и float в Си.
 *              Используется по умолчанию.
 *
 *      2.      Для вызова фортран-функции из Си ее нужно описать
 *              ключевым словом fortran. Порядок параметров - тот же.
 *              Параметры передаются по ссылке. Типы integer и real в
 *              фортране соответствует long и float в Си.
 *              Включается флагом -DMSF.
 */

# ifdef MSF
#       define  IBCD    fortran ibcd
#       define  BCD     fortran bcd
#       define  IADR    fortran iadr
#       define  LDBYTE  fortran ldbyte
#       define  IPEEK   fortran ipeek
#       define  PEEK    fortran peek
#       define  IPOKE   fortran ipoke
#       define  POKE    fortran poke
#       define  SYMTAB  fortran symtab
# else
#       define  IBCD    ibcd_
#       define  BCD     bcd_
#       define  IADR    iadr_
#       define  LDBYTE  ldbyte_
#       define  IPEEK   ipeek_
#       define  PEEK    peek_
#       define  IPOKE   ipoke_
#       define  POKE    poke_
#       define  SYMTAB  symtab_
# endif

# define LEN 8          /* длина текстовой строки для bcd, ibcd */
# define INTEGER long   /* тип integer в фортране соответствует long в Си */
# define REAL float     /* тип real в фортране соответствует float в Си */

static short index0 [96] = {
	301,    227,    293,    769,    763,    261,    233,    285,
	303,    245,    241,    223,    257,    223,    217,    305,
	159,    165,    169,    173,    181,    185,    191,    197,
	201,    209,    279,    247,    221,    289,    269,    271,
	/* LAT */
	775,    1,      5,      21,     13,     17,     5,      21,
	27,     31,     35,     39,     43,     45,     49,     51,
	5,      51,     57,     63,     71,     35,     73,     75,
	79,     83,     87,     215,    255,    239,    253,    301,
	/* lat */
	775,    315,    321,    327,    333,    327,    339,    343,
	351,    355,    359,    363,    367,    371,    375,    379,
	379,    385,    375,    391,    397,    399,    405,    409,
	413,    405,    417,    215,    255,    239,    253,    301,
};

static char width0 [96] = {
	0,      11,     13,     11,     12,     14,     10,     6,
	4,      4,      8,      5,      6,      2,      5,      2,
	9,      5,      8,      13,     6,      9,      12,     6,
	16,     12,     11,     12,     3,      5,      3,      13,
	/* LAT */
	16,     8,      13,     8,      7,      7,      6,      10,
	6,      6,      6,      6,      3,      5,      4,      9,
	9,      12,     11,     12,     4,      7,      3,      5,
	5,      5,      7,      4,      2,      4,      3,      0,
	/* lat */
	16,     11,     12,     8,      10,     10,     8,      13,
	6,      5,      6,      6,      4,      5,      7,      9,
	11,     11,     6,      10,     4,      7,      3,      5,
	5,      5,      4,      4,      2,      4,      3,      0,
};

static short index1 [96] = {
	301,    227,    293,    769,    763,    261,    233,    285,
	303,    245,    241,    223,    257,    223,    217,    305,
	159,    165,    169,    173,    181,    185,    191,    197,
	201,    209,    279,    247,    221,    289,    269,    271,
	/* RUS */
	145,    1,      91,     123,    99,     17,     307,    95,
	79,     111,    111,    39,     115,    45,     27,     51,
	95,     153,    5,      21,     71,     117,    105,    5,
	91,     133,    173,    127,    139,    127,    181,    301,
	/* rus */
	497,    315,    419,    465,    431,    327,    459,    425,
	413,    399,    399,    363,    449,    371,    351,    379,
	375,    505,    379,    327,    397,    453,    437,    321,
	487,    481,    443,    475,    491,    475,    471,    301,
};

static char width1 [96] = {
	0,      11,     13,     11,     12,     14,     10,     6,
	4,      4,      8,      5,      6,      2,      5,      2,
	9,      5,      8,      13,     6,      9,      12,     6,
	16,     12,     11,     12,     3,      5,      3,      13,
	/* RUS */
	13,     8,      8,      7,      10,     7,      16,     4,
	5,      4,      7,      6,      3,      5,      6,      9,
	5,      9,      9,      8,      4,      10,     12,     13,
	7,      12,     13,     9,      11,     10,     6,      0,
	/* rus */
	13,     11,     12,     9,      12,     10,     12,     10,
	5,      7,      10,     6,      5,      5,      6,      9,
	7,      10,     11,     8,      4,      10,     12,     12,
	7,      10,     11,     9,      11,     12,     6,      0,
};

static short index2 [96] = {
	301,    681,    751,    735,    63,     719,    685,    745,
	673,    695,    691,    677,    715,    707,    669,    711,
	159,    165,    169,    173,    181,    185,    191,    197,
	201,    209,    731,    699,    755,    747,    759,    727,
	/* GREEK */
	739,    511,    5,      95,     515,    17,     307,    95,
	27,     31,     517,    39,     115,    45,     49,     51,
	525,    529,    5,      537,    71,     83,     541,    549,
	79,     83,     87,     667,    713,    689,    703,    723,
	/* greek */
	739,    555,    561,    569,    419,    573,    579,    569,
	585,    589,    591,    597,    601,    605,    611,    379,
	613,    617,    625,    631,    637,    641,    645,    651,
	657,    641,    661,    667,    713,    689,    703,    723,
};

static char width2 [96] = {
	0,      5,      5,      8,      15,     6,      8,      4,
	5,      5,      5,      8,      6,      7,      6,      2,
	9,      5,      8,      13,     6,      9,      12,     6,
	16,     12,     6,      6,      6,      8,      6,      5,
	/* GREEK */
	9,      6,      13,     4,      4,      7,      16,     4,
	6,      6,      16,     6,      3,      5,      4,      9,
	6,      16,     9,      7,      4,      5,      16,     10,
	5,      5,      7,      3,      4,      3,      7,      7,
	/* greek */
	9,      10,     14,     7,      12,     11,     10,     7,
	7,      3,      12,     6,      5,      9,      4,      9,
	6,      14,     9,      9,      5,      7,      10,     11,
	8,      7,      9,      3,      4,      3,      7,      7,
};

static char stab [] = {
	8,2,57,25,      66,72,5,69,     6,2,6,54,       57,9,71,72,
	69,54,50,67,    0,2,0,0,        9,2,72,57,      50,67,0,2,
	2,66,53,5,      9,5,0,73,       57,72,8,25,     18,3,67,50,
	53,69,0,0,      9,2,69,5,       66,73,0,0,      50,18,41,34,
	57,25,0,0,      67,73,18,50,    4,3,0,9,        9,2,73,5,
	66,22,0,0,      2,66,0,9,       9,2,73,38,      0,66,0,0,
	9,2,73,66,      8,25,18,3,      67,50,57,72,    114,25,66,51,
	6,2,6,54,       57,9,71,72,     38,54,0,66,     18,3,67,50,
	54,69,7,22,     25,8,72,57,     41,114,0,34,    73,9,34,41,
	34,9,0,73,      2,9,66,37,      0,73,0,0,       73,2,9,114,
	0,66,0,0,       38,9,38,34,     0,73,0,0,       73,9,66,2,
	22,114,0,54,    54,6,67,69,     2,50,73,9,      9,2,72,73,
	0,66,0,0,       2,1,81,82,      66,82,25,73,    18,41,0,0,
	22,2,22,9,      41,38,38,34,    73,54,66,54,    2,9,66,73,
	25,112,0,57,    41,2,0,66,      5,9,52,20,      73,69,50,67,
	3,18,0,0,       2,9,73,66,      82,66,0,65,     2,9,39,34,
	66,34,66,73,    65,82,0,0,      3,9,34,18,      53,51,22,38,
	112,5,66,73,    18,3,67,50,     22,70,72,70,    25,57,0,8,
	9,2,22,6,       41,24,72,57,    50,67,19,34,    0,22,0,0,
	73,66,8,25,     21,6,21,69,     0,2,0,0,        4,18,25,7,
	71,57,50,68,    0,18,0,0,       50,18,41,34,    0,24,0,0,
	25,8,72,57,     3,70,66,2,      25,8,72,57,     54,71,54,22,
	67,69,18,50,    0,3,0,0,        6,9,69,21,      66,73,0,0,
	9,73,54,6,      67,69,18,50,    0,3,0,0,        57,72,8,25,
	18,3,67,50,     54,69,5,22,     9,8,72,73,      18,19,0,0,
	7,22,25,8,      72,57,54,71,    5,22,18,3,      67,50,54,69,
	18,3,67,50,     57,72,8,25,     21,6,70,53,     2,34,41,9,
	19,18,34,35,    0,18,0,0,       6,72,112,68,    69,5,39,37,
	0,35,0,0,       34,35,51,50,    112,35,41,36,   52,57,0,36,
	23,66,41,24,    5,56,19,4,      68,35,0,0,      66,34,41,73,
	71,3,7,112,     112,67,5,69,    67,50,57,72,    23,22,38,39,
	112,22,19,35,   36,20,18,35,    69,5,0,68,      66,9,0,0,
	35,18,20,36,    35,19,0,0,      8,24,25,9,      112,24,2,73,
	51,112,66,67,   51,50,0,0,      70,8,112,4,     35,18,18,34,
	36,112,54,38,   72,71,25,57,    0,8,0,0,        20,19,35,36,
	112,19,23,22,   38,39,0,22,     40,25,23,39,    40,24,0,0,
	70,6,68,114,    0,4,0,0,        40,25,23,39,    40,24,57,112,
	71,72,56,55,    0,72,0,0,       0,0,0,0,        35,50,57,40,
	73,2,0,0,       50,18,40,34,    7,24,19,4,      68,51,56,71,
	41,40,57,25,    22,5,69,54,     50,67,3,18,     68,20,0,66,
	67,50,53,68,    4,21,24,39,     3,8,50,18,      50,67,3,18,
	22,5,69,54,     4,68,0,0,       54,69,5,22,     18,3,67,50,
	72,66,0,0,      22,18,54,6,     23,22,56,40,    16,1,65,48,
	54,69,5,22,     18,3,67,50,     0,70,0,0,       6,2,52,4,
	50,54,0,0,      38,34,39,112,   0,40,0,0,       34,17,112,38,
	40,39,0,0,      8,2,54,4,       50,4,0,0,       34,50,24,19,
	6,22,0,38,      6,2,70,35,      0,66,0,0,       6,2,22,5,
	69,54,0,66,     22,5,69,54,     50,67,3,18,     6,5,0,0,
	54,69,5,22,     18,3,67,50,     64,70,0,81,     18,3,67,50,
	20,52,22,5,     69,54,0,0,      38,34,70,6,     3,6,50,18,
	66,67,112,70,   22,54,0,0,      34,6,34,70,     0,32,0,0,
	18,6,50,36,     0,70,0,0,       70,2,6,36,      0,66,0,0,
	70,6,66,2,      69,54,50,67,    3,18,22,5,      7,54,72,24,
	22,5,69,54,     20,52,18,3,     67,50,0,0,      54,69,5,22,
	18,3,67,50,     56,71,7,24,     20,6,20,2,      38,36,36,34,
	70,52,66,52,    22,5,53,38,     51,36,32,49,    1,16,0,35,
	21,2,54,38,     0,50,0,0,       3,6,50,18,      70,67,48,65,
	1,16,0,0,       22,38,3,5,      50,18,69,67,    38,54,32,39,
	3,6,34,18,      54,51,66,50,    0,49,0,0,       5,6,52,20,
	50,54,0,0,      3,6,35,18,      35,38,67,50,    66,70,65,82,
	2,6,51,34,      37,52,112,5,    66,70,0,0,      37,5,51,52,
	2,34,0,6,       18,3,67,50,     36,68,69,68,    22,54,0,5,
	6,2,20,4,       34,19,67,50,    54,69,21,38,    0,20,0,0,
	19,2,54,52,     5,22,19,4,      50,52,0,0,      25,2,21,53,
	66,53,0,0,      41,2,2,66,      4,7,50,18,      71,70,25,57,
	112,7,21,23,    54,22,53,55,    25,18,73,9,     50,57,0,0,
	2,3,67,66,      53,112,54,55,   21,22,112,23,   9,8,72,73,
	66,67,54,2,     73,9,0,72,      5,8,36,20,      18,34,34,50,
	25,41,41,57,    52,36,72,69,    18,2,7,4,       57,25,68,71,
	66,50,0,0,      53,66,22,38,    3,5,34,18,      70,51,0,0,
	7,0,56,24,      70,71,21,53,    68,53,50,67,    3,18,0,0,
	21,6,32,34,     53,34,0,70,     54,69,5,22,     52,20,3,20,
	50,18,0,67,     5,22,18,3,      67,50,54,69,    32,38,0,0,
	6,2,22,5,       69,54,0,64,     34,38,0,50,     4,5,50,18,
	69,68,6,5,      56,24,69,70,    19,6,70,2,      66,53,0,0,
	38,2,38,8,      0,66,0,0,       19,0,19,22,     50,34,66,67,
	0,70,0,0,       37,6,70,50,     22,18,70,6,     50,54,0,0,
	55,26,55,71,    5,6,68,52,      3,52,17,2,      64,65,0,0,
	5,0,54,22,      67,69,18,50,    0,3,0,0,        22,70,3,5,
	50,18,69,67,    0,38,0,0,       22,5,38,70,     0,34,0,0,
	3,6,50,18,      69,67,0,54,     3,6,34,18,      39,32,50,34,
	70,67,0,0,      5,22,18,3,      37,35,50,35,    69,67,0,54,
	22,6,0,35,      35,70,64,48,    23,8,72,55,     3,4,66,18,
	0,65,0,0,       5,65,0,73,      7,3,56,24,      67,71,0,0,
	38,5,5,36,      0,85,0,0,       70,6,40,38,     112,36,67,3,
	41,34,55,23,    0,41,0,0,       17,2,50,33,     58,41,89,74,
	69,1,0,9,       21,5,58,33,     0,90,0,0,       85,5,52,54,
	0,85,0,0,       19,67,6,4,      71,23,0,0,      36,100,5,67,
	38,71,0,102,    66,2,6,70,      73,70,0,9,      41,34,0,0,
	22,5,85,69,     4,8,51,19,      72,68,0,0,      22,9,22,54,
	73,34,0,0,      68,4,101,35,    70,39,0,6,      20,34,34,52,
	0,41,0,0,       51,3,70,68,     7,55,0,0,       68,4,70,112,
	112,6,55,19,    20,3,112,16,    36,32,64,68,    0,32,0,0,
	34,39,2,66,     67,3,69,112,    112,5,71,7,     18,23,50,112,
	0,55,0,0,       6,72,112,68,    3,67,0,0,       70,8,112,4,
	67,3,0,0,       20,3,67,52,     54,52,54,71,    7,22,20,22,
	68,4,70,112,    112,6,18,40,    34,112,0,56,    51,68,4,19,
	24,7,71,56,     52,69,39,55,    21,22,53,36,
};

static char *strappend (s, p)
register char *s, *p;
{
	while (*s++ = *p++);
	return (s-1);
}

static char *ltoa (val)
long val;
{
	static char buf [30];
	register char *bp = buf + 29;
	register long qval = val, n;

	/* Convert long integer to ascii string using %d format. */
	/* Returns pointer to internal buffer. */
	*bp = 0;
	if (val == 0) {
		*--bp = '0';
		return (bp);
	}
	qval = qval<0 ? -qval : qval;
	while (qval > 0) {
		n = qval;
		qval /= 10;
		*--bp = n - qval * 10 + '0';
	}
	if (val < 0)
		*--bp = '-';
	return (bp);
}

static char *ftoa (val, prec)
register double val;
{
	static char buf [40];
	register char *p = buf;

	/* Convert double to ascii string +- aaaa.bbbb. */
	/* Returns pointer to internal buffer. */
	if (val < 0) {
		*p++ = '-';
		val = -val;
	}
	p = strappend (p, ltoa ((long) val));
	*p++ = '.';
	val -= (long) val;
	if (prec > 7)
		prec = 7;
	while (--prec >= 0)
		val *= 10;
	p = strappend (p, ltoa ((long) val));
	*p = 0;
	return (buf);
}

static str8cpy (s, p)
register char *s, *p;
{
	register i;
	register char *bs, *bp;

	/* copy string p to buffer s right flushed */
	/* size of s is 8 bytes */
	bs = s;
	bp = p;
	for (i=8; --i>=0; *s++ = ' ');          /* fill s with blanks */
	while (*p++);                           /* skip to the end of p */
	for (--p; p>bp && s>bs; *--s = *--p);   /* copy string */
}

IBCD (i, s)
INTEGER *i;
char *s;
{
	if (*i < -9999999 || *i > 99999999)
		str8cpy (s, "**  ");
	else
		str8cpy (s, ltoa ((long) *i));
}

BCD (f, s, n)
REAL *f;
char *s;
INTEGER *n;
{
	if (*f < -9999999 || *f > 99999999)
		str8cpy (s, "**  ");
	else if (*n <= 0)
		str8cpy (s, ltoa ((long) *f));
	else
		str8cpy (s, ftoa ((double) *f, (int) *n));
}

INTEGER LDBYTE (s, n)
char *s;
INTEGER *n;
{
	return (s [*n-1] & 0377);
}

INTEGER IPEEK (p, o)
INTEGER *p, *o;
{
	return (((INTEGER *) *p) [*o - 1]);
}

REAL PEEK (p, o)
INTEGER *p, *o;
{
	return (((REAL *) *p) [*o - 1]);
}

IPOKE (p, o, n)
INTEGER *p, *o, *n;
{
	((INTEGER *) *p) [*o - 1] = *n;
}

POKE (p, o, n)
INTEGER *p, *o;
REAL *n;
{
	((REAL *) *p) [*o - 1] = *n;
}

INTEGER IADR (p)
INTEGER *p;
{
	return ((INTEGER) p);
}

/*
 *      Compute polyline for drawing symbol.
 *
 *      Input:
 *              jtext   - text string
 *              i       - number of byte to draw 1..
 *              iset    - number of symbol set 0..3
 *      Output
 *              nplot   - array of points
 *              kk      - number of points in nplot
 */

SYMTAB (jtext, i, nplot, kk, iset)
char *jtext;
INTEGER nplot [16] [2], *i, *kk, *iset;
{
	register sym, k, kt;
	int index, width, set;

	for (k=0; k<16; ++k)
		nplot [k] [0] = nplot [k] [1] = 0;

	sym = jtext [*i-1] & 0377;
	set = *iset;
	if (sym >= 0200) {
		sym = remap (sym);
		set ^= 1;
	}
	sym = (sym & 0177) - ' ';
	if (sym < 0)
		sym = 0;
	switch (set) {
	default:
	case 0:
		width = width0 [sym];
		index = index0 [sym];
		break;
	case 1:
		width = width1 [sym];
		index = index1 [sym];
		break;
	case 3:
		if (sym >= 040)
			sym ^= 0140;
	case 2:
		width = width2 [sym];
		index = index2 [sym];
		break;
	}

	index = (index - 1) * 2;
	for (k=0; k<width; k+=2, index+=2) {
		kt = stab [index+1];
		nplot [k] [0] = kt >> 4;
		nplot [k] [1] = kt & 017;
		kt = stab [index];
		nplot [k+1] [0] = kt >> 4;
		nplot [k+1] [1] = kt & 017;
	}
	*kk = width;
}

static remap (c)
register c;
{
	return ((c &= 0177) < 0100 ? c : c ^ 040);
}
